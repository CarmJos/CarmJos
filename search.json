[{"title":"C语言命名规范——以UNIX风格为例","url":"/doc/c-name-rules.html","content":"\n# C语言命名规范——以UNIX风格为例\n\n优秀的C语言代码通常遵循通用的代码规范原则，以确保代码的可读性和一致性。\n\n虽然这些规则不是强制性的，但遵循它们可以大大帮助保持代码的逻辑可读性和一致性，特别是在团队协作或大型项目中。\n不同的项目或团队可能有自己的命名约定，所以最重要的是在一个项目或团队内保持一致性。\n\n## 基本规范\n\n1. **避免使用保留字和标准库命名**:\n    - 避免使用C语言的关键字（如 `int`, `return`, `struct` 等）作为变量名。\n    - 同样，避免使用可能与标准库函数冲突的名称。\n\n2. **使用简洁且具有描述性的名称**:\n    - 选择简洁且具有描述性的名称，使其能够清晰地表达变量或函数的用途。例如，使用 `calculate_speed()` 而不是 `cs()`。\n    - 避免使用无意义的名称，如 `a`、`qwq` 或 `foo`。\n    - 选择单词时，首先要保障“**贴切**”，即词能达意，其次再去考虑长短。\n    - 尽量避免使用缩写，除非它们是通用的或广泛使用的。例如，`str` 代表字符串，`len` 代表长度。见 [通用缩写](#通用缩写)。\n\n3. **保持一致性**：在同一项目或团队中保持文件命名的一致性非常重要。个人或团队内部应该商定并遵守统一的命名规范。\n\n> _注1:_ 也有一种命名函数名的风格是 首字母小写,后面单词首字母大写,中间不用连接符, 比如 `getMaxValue()`。\n> 而类名单词首字母大写不用分隔符,如 `class MyDateClass`；\n> 类的成员数据和方法的首单词首字母小写后面的单词首字母大写 如 `int superValue`。\n>\n> JAVA的代码风格就是大致如此。\n\n## 特定情况\n\n### 1. 文件命名\n\n在C语言项目中，文件命名的规范有助于帮助构建项目的整体结构。以下是一些常见的文件命名规范：\n\n1. **使用小写字母**：文件名通常全部使用小写字母，以避免操作系统之间的兼容性问题（特别是在区分大小写的系统中）。\n2. **使用下划线分隔**：单词之间使用下划线（_）分隔，以提高可读性。例如：`char_calc.c` 或 `data_processing.h`。\n3. **简洁且具描述性**：文件名应简洁且能够清楚地描述文件内容。例如，如果文件包含一个实现链表功能的模块，则可以命名为 `linked_list.c`。\n4. **区分头文件和源文件**：\n    - 源文件（.c 文件）：包含C语言的实现代码。例如：`main.c`, `score_calc.c`。\n    - 头文件（.h 文件）：包含函数声明、宏定义和类型定义等。与源文件相关联，通常名称相似。例如：`utils.h` 用于存放工具方法。\n5. **避免使用空格和特殊字符**：避免在文件名中使用空格和特殊字符，如`%`, `&`, `*`等，因为它们可能导致在某些环境或命令行操作中出现问题。\n6. **使用有意义的前缀或后缀**：对于大型项目，可以使用前缀或后缀来指示文件属于哪个模块或子系统。例如，使用`gui_button.c` 来表示该文件为图形用户界面模块中的按钮相关代码。\n7. **避免过长的文件名**：虽然现代操作系统支持较长的文件名，但过长的文件名可能不便于管理、识别和调用。所以，尽量保持文件名长度合理。\n\n### 2. 变量与常量\n\n局部变量命名应当 **全部使用小写字母，单词之间用下划线分隔** 。\n局部变量可以简短，因为它们的作用域有限。例如：\n\n- `int my_variable;`\n- `void calculate_total();`\n\n全局变量应该更加谨慎命名，可以使用前缀以避免命名冲突，例如：\n- `int g_some_value = 10;` 其中 `g_` 为前缀，代表 _GLOBAL_，即全局。\n\n对于常量，可以使用 `const` 关键字来定义，并采用 **全大写下划线** 风格例如：\n- `static const int DENOMINATIONS[] = { 2000, 1000 };` [[实例]](https://github.com/carm-outsource/CWorks/blob/master/src/calculator/change_calc.c#L7)\n\n而 `i, j, k, m, n, x, y, z` 等单字母变量普遍被用在索引、循环语句控制、数学函数等处。\n这是一种约定俗成的习惯，但是在其他地方使用单字母变量是不被推荐的，且不应当滥用。\n\n\n### 3. 方法与函数\n\n针对于方法，我们一般采取 “`动词_名词`” 的命名方式，且应当 **全部使用小写字母，单词之间用下划线分隔** ，例如：\n- `int get_file();`\n- `int calculate_total();`\n- `int get_max_value();`\n- `int is_valid();`\n\n其中“动词” 通常用于表示方法的操作，例如 `calculate_total()` 计算总数，\n“名词” 通常用于表示方法的返回值类型，例如 `get_max_value()` 返回一个最大值。\n该部分是可选的，比如 有些方法不需要返回值，或者返回的内容已经隐藏在动词方法名或模块名中。\n\n### 4. 类型与结构体\n\n自定义类型（如结构体和联合体）通常使用**大驼峰式**或**全大写下划线**风格。例如：\n- `typedef struct { ... } MyStruct;`\n- `typedef struct { ... } MY_STRUCT;`\n\n### 5. 宏变量与枚举\n\n宏常量和枚举通常全部使用大写字母，单词之间用下划线分隔。这样做是为了与普通变量和函数区分开。例如：\n- `#define MAX_LENGTH 100`\n- `enum { RED, GREEN, BLUE };`\n\n## 常见操作单词\n\n- add/remove\n- begin/end\n- create/destroy\n- insert/delete\n- first/last\n- get/release\n- increment/decrement\n- put/get\n- add/delete\n- lock/unlock\n- open/close\n- min/max\n- old/new\n- start/stop\n- next/previous\n- source/target\n- show/hide\n- send/receiver\n- source/destination\n- copy/paste\n- up/down\n\n\n## 通用缩写\n\n这里是一些通用的缩写，选择性使用。\n\n```text\naddition —> add\nanswer —> ans\narray —> arr\naverage—>avg \nargument —> arg\nbuffer —> buff/buf\nclock —> clk\ncalculate —> calc\ncolumn —> col\ncontrol —> ctrl\ncommand —> cmd\ncompare —> cmp\nconfiguration —> config/cfg\ncount —> cnt\ndefine —> def\ndelete —> del\ndestination—>dst/dest\ndisplay—> disp\ndevice —> dev\ndecode —> dec\ndivision —> div\nfrequency—>freq\nerror —> err\nenvironment —> env\nencode —> enc\nhexadecimal —> hex\nheader —> hdr\nindex —> idx\nimage —> img\ninitialize —> init\nincrement —> inc\nlength—>len\nmake —> mk\nmaximum —> max\nmessage —> msg\nminimum —> min\nmultiplication—>multi\nmemory—>mem\nmiddle—>mid\nnumber —> num\noption—>opt\nparameter —> para\nprevious —> prev\npointer —> ptr\nregister —> reg\nreceiver—>recv\nreturn —> ret\nresult—>res\nsource —> src\nstack—>stk\nstring—>str\nsubtraction—>sub\nsemaphore —> sem\nstatistic —> stat\nsynchronize —> sync\ntable —>tab\ntemp —> tmp\ntemporary—>tmp/temp\ntimestamp—>ts\nvalue—>val\nwidth—>wid\n```","tags":["dev"],"categories":["doc"]},{"title":"为何我的部分轻量插件的体积十分“庞大”？","url":"/dev/why-plugins-huge.html","content":"\n有朋友和我说 “一个[自动领奖插件](https://github.com/CarmJos/TimeReward)就快400kb，是不是太臃肿了？”。 我觉得针对这种问题应当统一作出解释。\n\n## 关于用户体验\n这其实是一种个人代码风格的选择，不同开发者的风格也大多不相同。在很早的时候，我和这位朋友一样，对于一个明明功能很简单的插件打包了许多类库这种事情感到十分可笑。但随着我接的各种小单子越来越多，接触的用户越来越多，我发现程序员思维在这里似乎并不适用。\n\n其实这种问题只要做一个核心类库插件就全部解决了。但作为用户来说，相比于要额外安装一个依赖插件，我更喜欢开箱即用的感觉，而非安装一个插件需要额外安装许许多多杂七杂八的类库。举个例子，如果我想使用一个插件，需要额外安装作者的一个类库；如果要使用的插件来自于多个作者，岂不是需要额外安装许许多多的类库？\n\n因此，作为一个插件覆盖面并不广泛的开发者，我选择每个插件都单独打包类库，而让用户无需对此焦虑。\n\n## 关于高版本接口\n\n这时候又有人想问“为何不使用高版本提供的依赖接口，直接让服务端下载依赖使用，从而减小插件的大小呢？”\n\n其实理由已经出现在问题里了。没错，这个功能需要“**高版本**”。\n\n相比于为了减小插件体积而使用这个功能，以导致只有高版本才可以使用，我更倾向于让一个插件能够覆盖到更多的版本，从而减少用户的选择成本。\n\n让我们回到用户的视角，面对一个功能需求上很适合自己的插件，却因为版本过低而无法使用，而这的原因仅仅是开发者为了让插件看上去更“轻量化”去使用高版本的依赖接口从而失去了低版本用户的支持，我相信，这个时候用户更希望的是在自己的服务器也能用上这款插件，而不是我们需要的“轻量化”。\n\n## 总结\n\n总而言之，是否打包类库到插件纯属开发者的个人习惯。有的人喜欢“轻量”而自行挑选重要内容放到自己的插件中，有的人更爱“便捷”而一股脑全塞上，也有的人会为了“用户体验”而做出一点大小上的牺牲。\n\n如果是三年前的我，我会强烈推荐你做一个“依赖库插件”，它能够很好的解决插件实际功能和大小不等的问题同时还能让这个插件在不同的服务器版本中得到支持；\n但如果是现在的我，我会推荐你好好考虑，对于单个功能插件，在必要的情况下直接打包依赖库也完全没问题的：虽然需要在“轻量化”上做出一些牺牲，但可以让使用的用户得到更好的体验，在我看来这是一个更好的决定。\n\n---\n文章作者为 @CarmJos ，同时感谢 @nelson 帮助校对文章。\n\n","tags":["dev"],"categories":["开发经验分享"]},{"title":"自动部署Javadoc到Github Pages","url":"/doc/javadoc-in-github.html","content":"\n## 需求\n\n由于想开一个新坑，打算把项目通过Maven生成的的Javadoc使用 [Github Actions](https://docs.github.com/en/actions/learn-github-actions) 自动部署到同项目下 `gh-pages` 分支，作为该项目 [Github Pages](https://pages.github.com/) 的主页供其他人参考。\n\n## 操作\n\n### 1. 配置 Maven 生成JavaDoc\n\n首先在项目的 `pom.xml` 中添加 [Maven Javadoc Plugin](https://maven.apache.org/plugins/maven-javadoc-plugin/) ,依赖这个插件，我们可以自动生成JavaDoc。\n\n```xml\n<plugins>\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-javadoc-plugin</artifactId>\n        <version>3.2.0</version>\n        <configuration>\n            <classifier>javadoc</classifier>\n            <detectJavaApiLink>true</detectJavaApiLink>\n            <encoding>UTF-8</encoding>\n            <charset>UTF-8</charset>\n            <docencoding>UTF-8</docencoding>\n            <!-- <locale>zh_CN</locale> 可选，使用中文的界面-->\n        </configuration>\n        <executions>\n            <execution>\n                <id>attach-javadocs</id>\n                <goals>\n                    <goal>jar</goal>\n                </goals>\n            </execution>\n        </executions>\n    </plugin>\n<plugins>\n```\n\n设置过后，我们就可以输入 `mvn javadoc:javadoc` 命令生成该项目的Javadoc了，生成的路径一般在 `target/site/apidoc/` 下。\n\n!!! note \"\"\n    如果是使用的 `mvn package` 命令，则会生成在 `target/apidoc/` 下。\n\n### 2. 配置Github项目的`Deploy Keys`与`Secrets`\n\n因为我们需要把Javadoc放到同项目下的`gh-pages`分支，因此在Actions中需要进行认证操作，才可以正常推送。\n\n这里我们打算采用SSH进行推送，并通过 Deploy Keys 进行认证。\n\n#### a. 生成 OpenSSH 密钥\n\n我们可以访问 [Generate SSH Keys Online](https://8gwifi.org/sshfunctions.jsp) 在线生成一个密钥。\n\n![generate key](/images/javadoc-in-github/generate-key.png)\n\n点击后，在下方会生成对应的私钥(Private Key)与公钥(Public Key)，我们先记下。\n\n#### b. 添加私钥到 `Secrets`\n\n复制上一步得到的私钥，添加到项目的`Secrets`中。\n\n![add secret](/images/javadoc-in-github/add-secret.png)\n\n名字(Name)填`DEPLOY_PRI`,数值(Value)填私钥内容\n\n![confirm secret](/images/javadoc-in-github/confirm-add-secret.png)\n\n#### c. 添加公钥到 `Deploy Keys`\n\n复制之前得到的公钥，添加到项目的`Deploy Keys`中。\n\n![add deploy key](/images/javadoc-in-github/add-deploy-keys.png)\n\n名字(Title)可以随便填，我这里选择的是`JAVADOC_DEPLOY`，密钥(Key)填公钥内容。注意一定要勾选 \"**Allow write access**\", 这样才可以被用于推送。\n\n![confirm deploy key](/images/javadoc-in-github/confirm-add-deploy-key.png)\n\n### 3. 配置 Github Actions\n在项目下新建 `.github/workflows/javadoc.yml` 文件。这个文件会被自动识别为[Github Actions](https://docs.github.com/en/actions/learn-github-actions)配置文件。\n\n!!! note \"\"\n    记得也要在Settings中启用 Github Actions ，否则无法使用哦。\n    \n内容如下\n```yml\nname: Javadoc\n\non:\n  # 支持手动触发构建\n  workflow_dispatch:\n  release:\n    # 创建release的时候触发\n    types: [ published ]\n#  push: # 可选，在推送主分支时触发\n#    branches:\n#    - main\n#    - master\n\njobs:\n  apidoc-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout the repo\n        uses: actions/checkout@v2\n\n      - name: Set up the Java JDK\n        uses: actions/setup-java@v2\n        with:\n          java-version: '11'\n          distribution: 'adopt'\n\n      - name: Generate docs #生成Javadoc\n        run: mvn javadoc:javadoc\n\n      - name: Copy to Location # 复制Javadoc到一个新文件夹，便于进行git操作\n        run: |\n          rm -rf docs\n          mkdir -vp docs\n          cp -vrf target/site/apidocs/* docs/\n\n      - name: Generate the sitemap # 可选，生成sitemap\n        id: sitemap\n        uses: cicirello/generate-sitemap@v1\n        with:\n          base-url-path: https://carmjos.github.io/userprefix\n          path-to-root: docs\n\n      - name: Configure Git # 配置Git\n        env:\n          DEPLOY_PRI: ${{secrets.DEPLOY_PRI}} # 这里就是刚刚配置的私钥了\n          GIT_USERNAME: ${{ github.repository_owner }} #Github用户名，这里用了Actions自带的变量，也可以写死。\n          GIT_EMAIL: ${{ github.repository_owner }}@user.github.com # 邮箱,可以写自己的邮箱。\n        run: |\n          sudo timedatectl set-timezone \"Asia/Shanghai\"\n          mkdir -p ~/.ssh/\n          echo \"$DEPLOY_PRI\" > ~/.ssh/id_rsa\n          chmod 600 ~/.ssh/id_rsa\n          ssh-keyscan github.com >> ~/.ssh/known_hosts\n          git config --global user.name '$DEPLOY_PRI'\n          git config --global user.email '$DEPLOY_PRI'\n\n\n      - name: Commit documentation # 提交文档到Git仓库\n        env:\n          GIT_URL: \"git@github.com:<USERNAME>/<PROJECT>.git\" # 项目的地址，注意要用SSH格式的。\n        run: |\n          cd docs\n          git init\n          git remote add origin $GIT_URL\n          git checkout -b gh-pages\n          git add -A\n          git commit -m \"API Document generated.\"\n\n      - name: Push javadocs # 推送\n        run: |\n          cd docs\n          git push origin HEAD:gh-pages --force\n```\n\n随后，推送项目，在Actions界面找到该配置，手动触发一次。\n\n![run-action](/images/javadoc-in-github/run-action.png)\n\n等待其正常跑完，即可发现多了一个 `gh-pages` 分支。\n\n### 4. 设置 Github Pages \n\n在项目的Settings界面找到 Pages 一栏，选择 `gh-pages` 分支，点击 Save ，等待片刻即可访问 `<用户名>.github.io/<项目名>` 看到项目的Javadoc了。\n\n![Setting Pages.png](/images/javadoc-in-github/setting-pages.png)\n\n## 参考文献\n\n- < [Github Actions Documentation](https://docs.github.com/en/actions) >\n- < [Apache Maven Javadoc Plugin](https://maven.apache.org/plugins/maven-javadoc-plugin/index.html) >\n- < [javadoc: publishing to github pages from a public repo](https://ucsb-cs56-pconrad.github.io/topics/javadoc_publishing_to_github_pages_from_public_repo/) >\n","tags":["dev","Java","Github"],"categories":["doc"]},{"title":"为什么Git分支开始从“master”变为“main”了？","url":"/doc/branch-main.html","content":"\n## 发现\n\n一开始接触 Git 的时候，默认的分支名都为 `master` ，包括后续使用的时候也习惯于输入`master`进行各类操作。\n\n而我最近发现，[Github](https://github.com) 与 [Gitlab](https://about.gitlab.com/) 都开始使用 `main` 取代原先的 `master`\n作为项目的默认主分支了，这是为什么呢？\n\n## 起源 - “Black Lives Matter”\n\n自2020年六月起，由于“Black Lives Matter”抗议活动持续发酵，而计算机行业中对`master`与`slave`这两个词的使用引起了部分人的反感。\n\n在抗议声起、社会动荡加剧之时，更多的人认为这些包含历史文化因素的词汇已经过时，且应当被替换，于是多个开源项目开始采取行动替换冒犯性的术语，其中包括 PHPUnit 和 Curl、OpenZFS 等。\n\n不仅仅是`master`与`slave`,还有许多相关的词汇如`whitelist`与`blacklist`都被计划更改为`allowList`与`denyList`。\n\n正如 [ZDNet](https://www.zdnet.com/article/github-to-replace-master-with-main-starting-next-month/) 所说，继续使用这些带有种族色彩的词汇可能会延长种族歧视。一些学者在 2018 年的期刊上写道，“这些术语不仅反映了种族主义文化，而且还强化、合法化和延续了它。”\n\n而 LinkedIn 的软件工程师 Gabriel Csapo 也在 Twitter 上表示，他也正在提出更新 Microsoft 内部库的请求，并删除任何带有种族歧视色彩的短语。\n\n## 行动\n\n在此背景下，一位Twitter网友的提议，而这一提议得到了GitHub CEO的支持。\n![Twitter](/images/branch-main/una_kravets.png)\n> #### @Una Kravets\n> 我很高兴将 GitHub 的默认分支结构从『master』改成『main』，我希望我们能和 @GitHub 一起以社区为单位来做这件事……\n> #### @Nat Friedman\n> 这是个好主意！ 我们正在朝这方面进行改进了！\n\n于是自 2020年10月1日 开始，Github上所有的新库便都开始以 `main` 命名，并开始逐渐的将原先`master`为主分支的库修改为以`main`为主分支。\n\n鉴于GitHub有4000多万用户、1亿多个存储库以及至少2800万个公共存储库，这是项艰巨的任务。 任何一个规划的失误都会导致Linux内核之类的项目代码无法访问。全球大批企业依赖Linux内核，一旦发生这类事件都可能引发灾难性的后果。\n\n于是，GitHub又做了以下更改以确保万无一失：\n\n- [更新了 GitHub.com](https://github.blog/changelog/2020-07-17-links-to-deleted-branches-now-redirect-to-the-default-branch/) 以直接重定向`master`分支到新的默认分支！\n- [更新了 Github Pages](https://github.blog/changelog/2020-07-31-build-and-deploy-github-pages-from-any-branch-beta/) 以支持从任一分支进行部署\n- [添加了用户、组织与企业设定](https://github.blog/changelog/2020-08-26-set-the-default-branch-for-newly-created-repositories/) 以设定默认的分支名与新项目的默认分支名。\n    - 需要注意的是，这些设定同时在 [GitHub.com](https://github.com/new) 与 [GitHub API](https://developer.github.com/v3/guides/getting-started/#create-a-repository) 生效。\n    - [Git 2.28](https://github.blog/2020-07-27-highlights-from-git-2-28/#introducing-init-defaultbranch) 也添加了一个类似的设定 `init.defaultBranch`。\n- [我们让重命名已有分支更加方便快捷了](https://github.com/github/renaming#rename-existing)\n\n## 参与\n\n如果还是习惯于使用 `master` 分支，那么大可不用更改继续使用下去。\n\n若想要支持相关的行动，则可以跟随以下的操作将`master`分支无损迁移到`main`分支。\n\n### 本地修改分支\n\n1. 首先将`master`分支移到`main`分支下\n\n```shell\ngit branch -m master main\n```\n\n2. 随后将新命名的分支`main`推送到远程库中\n\n```shell\ngit push -u origin main\n```\n\n3. 再将HEAD指向`main`分支\n\n```shell\ngit symbolic-ref refs/remotes/origin/HEAD refs/remotes/origin/main\n```\n\n4. 最后删除远程库中旧的`master`分支即可\n\n```shell\ngit push origin --delete master\n```\n\n### 在 GitHub 上修改默认分支\n\n用户、组织和企业可以在以下地址修改默认分支名。\n\n- 用户 `https://github.com/settings/repositories`\n- 组织所有者 `https://github.com/organizations/<组织名>/settings/repository-defaults`\n- 企业管理员 `https://github.com/enterprises/<企业名>/settings/member_privileges`\n\n![Settings](/images/branch-main/settings.png)\n\n## 参考文献\n\n- < [Github Renaming](https://github.com/github/renaming) >\n- < [GitHub to replace 'master' with 'main' starting next month](https://www.zdnet.com/article/github-to-replace-master-with-main-starting-next-month/) >\n- < [Why GitHub renamed its master branch to main](https://www.theserverside.com/feature/Why-GitHub-renamed-its-master-branch-to-main) >","tags":["dev","Git","Cultural"],"categories":["doc"]},{"title":"写给一位cn2b2t玩家的信","url":"/letter/cn2b2t.html","content":"\n尊敬的cn2b2t玩家：\n\n您好！\n\n一九年的七月二十日，我心血来潮，花了短短的一会时间制作了cn2b2t。令我意向不到的是，这小小的举动竟然引起了许多玩家的响应，让我们这群充满梦想与激情的开发者更有了一丝前进的动力。但有意经营管理经验不足，2020年7月17日，我们无奈的选择关服休整，让所有开发者回归学业，并尽力去打拼自己的未来。\n\n\n\n我们不得不向您致歉，我们使大量的玩家失去了过往的汗水与记忆，也失去了部分游戏中的战友，这也令我们难以释怀。好在，还有您愿意从我们手中接走回忆的接力棒，我也相信您也会很好的保留这些美好的记忆，谢谢您。\n\n\n\n同时我也须向您致歉，由于服务器数据保存不当，自2020年6月换新服后的数据难以读取，故我拷贝给予您的副本是较老的地图文件，还请您谅解。\n\n\n\nKar Network承载了我们数十位开发者、管理者的游戏梦，如今距关服已有三个月，回首过去，有喜悦，也有遗憾。喜悦在于拥有你们这些支持我们的玩家，遗憾则是我们没有为你们交出完美的答卷。我们会吸取过往的教训，总结成功的经验，并在不久的将来进行新的尝试。我们坚信，唯有用心与坚持，才能抓住新的机会。\n\n\n\n我们一直在努力，我们希望您也实现自己梦想的道路上继续坚持。我相信，我们将会在不久的将来，以全新的姿态，与您再会。这条梦想之路，我们与您手牵手，共同前行。\n\n\n\n望共勉！\n\n<div align=right>\n    <div>CarmJos</div>\n    <div>\n        2020年11月2日\n    </div>\n</div>\n\n## 后记\n\n本项目代码已开源，见 [cn2b2t-project(Github.com)](https://github.com/CarmJos/cn2b2t-project) 。如有需要可自取，希望能对社区有所帮助。\n","tags":["cn2b2t"],"categories":["书信"]},{"title":"Kar Network 关服通知","url":"/letter/kar-closed.html","content":"\n## 来自全体管理组成员的致歉书\n\n亲爱的玩家，大家好：\n\n\n\n自 2015 年首次开服以来，Kar Network 已经陪伴大家五个春秋，得到了广大玩家的支持与厚爱。回顾开服以来我们和各位一起度过了无数个欢乐的日子，由衷的感激大家给予的支持与帮助！\n\n\n\n由于运营不当，自2015年起遍入不敷出，至此已无法继续承担高额的维护费用。且由于现有所有服务环境(包括但不限于 服务管理器、开发站、服务器官网、服务器运行环境、构建开发环境)均基于本台主机，，这些环境所花费的金钱、时间和精力无法复制，无法还原，也就直接告示着未来的维护不再可能，我们在MineCraft的路上就此终结。\n\n\n\n综上所述，Kar Network、MineCarl 及其附属、相关服务器将在2020年7月20日凌晨00:00停止服务。\n\n\n\n借此机会，通知所有使用本团队运行环境的个体、团队，在关服前迁移所有相关数据，如关服后存在数据遗失问题，本团队概不负责，恳请谅解。\n\n\n\n最后感谢您的陪伴，希望在往后的日子里能与您共同回忆这段美好时光。也希望能在我们未来开发的其他游戏中再次见到您的身影。\n\n\n\n希望国内MineCraft的未来更加美好。若您还在寻找一个适合您的服务器，可以尝试访问 `McLists.cn`。\n\n\n\n祝大家生活愉快。\n\n<div align=right>\n    <div>Kar Network运营团队</div>\n    <div>\n        2020年7月17日\n    </div>\n</div>","tags":["kar"],"categories":["书信"]},{"title":"对我的世界中PVP击退的研究报告","url":"/dev/knockback-study.html","content":"\n# “脚本小子”对MC击退的研究成果\n\n该页面研究的是原版击退算法以及原版击退算法中的各值的作用。\n\n通常我们在调整击退参数的时候，都是靠感觉去调的。Kar团队另辟蹊径，通过数据和代码的方式去理解和调整最合适的击退。为了贯彻我们**决心**做中国PVP服领头羊的理念，我们决定将我们的研究成果分享出去。\n\n\n\n## 对于代码的分析\n\n### EntityLiving类\n\n由于在nms中部分变量经过了混淆，所以只能通过猜测得出这些变量的意义。\n\n在EntityLiving类中，玩家受到伤害时会触发`damageEntity`函数。\n\n![EntityLiving1.png](https://i.loli.net/2020/04/01/x1kWf4S3RtUjnwr.png)\n\n- d0为**攻击者**位置的X值减去**受害者**位置的X值，即为从**受害者**到**攻击者**的向量的X值。\n- d1初始值为**攻击者**位置的Z值减去**受害者**位置的X值，即为从**受害者**到**攻击者**的向量的Z值。\n\n我们把d0称为x，d1称为z，则\n\n- 若x²+z²<0.0001，则将d1设为一个-1至1之间的随机值\\*(见下方)，再乘以0.01，同时将d0也进行一次这样的操作。\n- 若x²+z²还是<0.0001，则再进行一次，直到不满足这个条件为止。\n\n推测，这可能是两个玩家坐标一样或极度相近的时候，为防止产生0变量，生成一个随机的击退。为验证这个猜测，您可以tp一名玩家，此时您的坐标和这名玩家是一模一样的(其实会产生一点点差别)。接着打他一下，发现击退有时候不在您面前的方向，甚至有时候击退到身后去了。\n\n\\*编个程统计一下这个随机数，进行100000000次(一亿次)模拟，发现其分布曲线是金字塔形。\n\n![分布是折线.png](https://i.loli.net/2020/04/03/7HlA3oyzxvtjqZY.png)\n\n它看起来大概是这样：\n\n![折线.png](https://i.loli.net/2020/04/03/Zd38TsJWUOSmwjo.png)\n\n设该折线的方程为 y = f(x), x∈(-1, 1)\n很明显，该随机变量X落在(-x, x),x∈(0, 1)的几率为\n\n![几率.png](https://i.loli.net/2020/04/01/LnA7QfboVySBEX5.png)\n\n![几率Latex](http://latex.codecogs.com/png.latex?\\frac{\\int_{-n}^{n}f%28x%29dx}{\\int_{-1}^{1}f%28x%29dx}=2x-x^2)\n\n```latex\n$\\frac{\\int_{-n}^{n}f(x)dx}{\\int_{-1}^{1}f(x)dx}=2x-x^2$\n```\n\n函数a中\n\n![EntityLiving2.png](https://i.loli.net/2020/04/01/rSVGJyPlBKc6HDW.png)\n\n其中的d0和d1即为上方所提的x和z\n设一个变量f1为\n\n![EntityLiving3.png](https://i.loli.net/2020/04/01/N62jPpTG3iVSaeQ.png)\n\n即为该向量在水平面上投影的距离\n\n1. 变量f2为0.4，我们把该值称为水平倍数，或者`Horizontal`\n2. 将`motX`、`motY`、`motZ`分别除以2，我们把该值称为`Friction`\n3. 接着将`motX` 减去 `x / f1 \\* f2`\n4. 将`motY` 加上 `f2`\n5. 将`motZ` 减去 `z / f1 \\* f2`\n6. 如果`motY`大于0.4，则设为0.4(这就是原版击退100附魔也无法飞天只能击远的原因)。我们把该值称为`VerticalLimit`。\n\n以上即为当受害者受到伤害时的原始击退算法。详细讲解请看下方**对原版击退算法的理解**。\n\n### EntityHuman类\n\n接着在**攻击者**的算法中，再次对产生的击退做出修正。\n\n在EntityHuman类中,**攻击者**攻击别人时，**受害者**会受到以下击退\n\n![EntityHuman1.png](https://i.loli.net/2020/04/01/kxVR9mA1EsTNfOG.png)\n\n其中，`i`为**攻击者**手上武器击退附魔的等级，若没有，则为0。\n如果**攻击者**正在疾跑，则`i`再加1。\n但是，在著名服务端mSpigot上，无论**攻击者**是否在疾跑，i的默认值都为1。\n\nyaw是**攻击者**的朝向的yaw值<s>(欧拉角警告)</s>，是角度制，所以后面的乘以π除以180是转为弧度制。\n`entity.g(double motX, double motY, double motZ)`函数为\n\n![Entity1.png](https://i.loli.net/2020/03/31/haRx8BJzAtIs4qO.png)\n\n意思为，该实体目前的速度向量加上这三个值，再把成员`ai`改为`true`。\n回到上面的击退计算，其中MathHelper是一个优化的数学<s>工具人</s>工具类\n于是，该操作可写为\n\n![算法1.png](https://i.loli.net/2020/03/31/lyx4WL1jcGS7OQC.png)\n\n\n\n\n```latex\n$\n\\begin{cases}\nmotX=motX+\\sin{\\frac{yaw*\\pi}{180°}*0.5i}\\\\\nmotY=motY+0.1\\\\\nmotZ=motZ+\\sin{\\frac{yaw*\\pi}{180°}*0.5i}\n\\end{cases}\n$\n```\n\n完成这些操作后，**攻击者**的`motX`和`motZ`各自会乘以0.6。\n\n!!! warning \"\"\n    是**攻击者**的`motX`和`motZ`会乘以0.6！**受害者**的击退已经算完了，不会乘以0.6缩短！\n\n\n由于我们平时在竞技场模式中并不会使用带击退附魔的东西当主武器，所以我们不考虑击退附魔。因此，我们只考虑`i`为0或1的情况。详细讲解请看下方**对原版击退算法的理解**\n我们把上面的0.5i的0.5称为疾跑水平加成(`SprintHorizontalBoost[SHB]`)，motY加的0.1称为疾跑竖直加成(`SprintVerticalBoost[SVB]`)\n\n\n\n## 猜测与实验\n\n\n玩家的击退对于**攻击者**的朝向只跟**攻击者**的yaw值有关，也就是环顾四周时的方向、水平方向有关，和pitch，也就是上下朝向无关。无论**攻击者**从上往下还是从下往上攻击，击退的原始数值只跟**攻击者**的yaw值和**攻击者**与**受害者**在水平面上的投影的向量有关，接着才根据玩家是否疾跑、武器有无击退、是否对该数值进行进一步计算。\n**但是**，如果**攻击者**既不在疾跑手上又没有击退附魔，则击退和yaw也无关。\n\n\n\n为了证明这一点，在采用原版击退的情况下，我做了个实验。\n\n先将敌人的坐标和自己的坐标精确控制在整数，以便计算。在所有条件都不变的情况下，攻击**受害者**，计算击退的大小。\n\n![实验1.png](https://i.loli.net/2020/04/01/9cmCE7o3ny5vIlU.png)\n\n|               | 第一次  | 第二次  | 第三次  |\n| :-----------: | :-----: | :-----: | :-----: |\n| 击退前x值坐标 |   -34   |   -34   |   -34   |\n| 击退后x值坐标 | -33.198 | -33.198 | -33.198 |\n\n重复3次实验发现，只要条件不变，每次击退都是一样的。\n\n\n接下来，只改变**攻击者**的**pitch值**，其他条件不变。\n\n|    pitch->    |   -10   |    0    |   10    |   20    |   30    |   40    |\n| :-----------: | :-----: | :-----: | :-----: | :-----: | :-----: | :-----: |\n| 击退前x值坐标 |   -35   |   -35   |   -35   |   -35   |   -35   |   -35   |\n| 击退后x值坐标 | -33.198 | -33.198 | -33.198 | -33.198 | -33.198 | -33.198 |\n\n使用不同的值重复多次实验，发现击退还是一样的。\n\n\n\n那么我们只改变**攻击者**的**yaw值**，其他条件不变。\n\n|     yaw->     |  -100   |   -95   |   -90   |   -85   |   -80   |\n| :-----------: | :-----: | :-----: | :-----: | :-----: | :-----: |\n| 击退前x值坐标 |   -35   |   -35   |   -35   |   -35   |   -35   |\n| 击退后x值坐标 | -33.198 | -33.198 | -33.198 | -33.198 | -33.198 |\n\n神奇的是，yaw值改变后，击退依然不变。\n\n\n\n接着，我们给**攻击者**手上的剑加上击退属性，再进行测试。\n同样只改变**攻击者**的**pitch值**，发现确实跟**攻击者**的**pitch值无关**。\n\n只改变**攻击者**的**yaw值**，得出以下结果：\n\n|     yaw->     |  -100   |   -95   |   -90   |   -85   |   -80   |\n| :-----------: | :-----: | :-----: | :-----: | :-----: | :-----: |\n| 击退前x值坐标 |   -35   |   -35   |   -35   |   -35   |   -35   |\n| 击退后x值坐标 | -31.034 | -31.009 | -31.001 | -31.009 | -31.034 |\n| 击退前z值坐标 |   -49   |   -49   |   -49   |   -49   |   -49   |\n| 击退后z值坐标 | -49.371 | -49.182 |   -49   | -48.818 | -48.629 |\n\n多次实验，发现每次结果都与上表相同。在**攻击者**手上附魔有击退效果时，击退与**攻击者**的**yaw值有关**。\n\n我们多测试了如果是**受害者yaw、pitch**改变是否会影响击退，结果是**受害者**的朝向完全不影响击退，实验方式和上面差不多，篇幅原因，在此不列出实验详细过程。\n\n测试**攻击者**疾跑对击退的影响，为了不改变坐标的值，写个插件欺骗服务器，**攻击者**在攻击时强制变成疾跑状态。测试结果是，疾跑状态攻击相当于手上拿着击退1的武器的效果。\n\n\n\n因此我们可以推测，用击退1的武器疾跑着攻击对方，相当于行走状态或静止状态用击退2攻击对方一样。通过实验，证实了该推测。\n\n我们再次推测，在击退与两个玩家的位置和**攻击者**的**yaw值有关**，且如果**攻击者**不在疾跑且手上武器没有击退附魔时，击退就只跟两名玩家的位置有关(除非去掉`if(i>0)`代码块使`motY+0.1`强制生效，许多服务端都有这样做)。\n\n\n\n用同样的方式，进行以下测试：\n- 测试**攻击者**与**受害者**所在位置存在高度差时，击退依然与上面一样，证明击退和高度差无关。\n- 测试**攻击者**与**受害者**所在位置的距离不同时，击退依然和上面一样。\n- 测试**攻击者**向**受害者**方向走动时攻击，击退依然和上面一样。\n- 测试**攻击者**跳劈，发现无论是上升状态还是下降状态，击退依然和上面一样。\n\n当**受害者**在空中时受到攻击，一般击退距离会更远。我们通过编写插件，使玩家站在地上(坐标和上面一样)时欺骗服务器玩家在空中，结果发现击退依然和上面一样。推测因为在空中，在掉落到地面之前有更长的时间在空中滑行，造成的更远击退的感觉。由于方块有Friction属性，也就是当玩家落到地面时速度会迅速降低，而空气的`Friction`比方块的要低，所以玩家在空中能被击退得更远。\n\n!!! note \"\"\n    这里所提到的方块`Friction`跟击退数值中的`Friction`不一样。\n\n## 各参数的作用\n回到参数上，如果不对原版击退的算法做出改变的话，仅修改算法中的几个参数，我们通常用感觉去判断击退的变化。通过了解上方原版击退的算法后，我们就可以知道那些参数的作用了。\n\n原始击退是指在原始计算中得到的`motX`、`Y`、`Z`的值。目前市面上很多击退插件是在最终击退值上乘以某倍数。\n\n### Friction\n指在**受害者**受到攻击时，受到攻击前**受害者**的速度除以的值，一般大于1，这也是为什么它叫Friction(摩擦)的原因。如果该值等于1，那么此时玩家的速度将会加上击退赋予玩家的速度。如果小于1，则玩家的速度会变大再加上击退赋予玩家的速度。如果大于1，则玩家的速度会先缩短，再加上击退赋予玩家的速度。原版该值为2.0\n\n### Horizontal\n指**原始**击退参数的`motX`、`motZ`减去值的倍数，原版为0.4\n\n### Vertical\n指**原始**击退参数的`motY`加上的值，原版为0.4\n\n### SprintHorizontalBoost, SHB\n指最终计算完毕的击退中的`motX`和`motZ`在**攻击者**水平面上所指位置(yaw值所对应位置)加上的，**攻击者**朝向的向量与x和z轴的投影距离，乘以击退附魔等级+若疾跑加一得到的倍数，再乘以的SHB，即原始数据再加上的击退距离的倍数，原版为0.5\n\n### SprintVerticalBoost, SVB\n指最终计算完毕的击退中的`motY`再加上的值，原版为0.1\n\n### VerticalLimit\n原始击退计算中，最高达到的`motY`，若超过这个值，则设为这个值。原版为`0.4000000059604645`\n\n\n\n## 对原版击退算法的理解(硬核慎入)\n\n注意，当玩家静止不动或者站在地面时，他的`motY`为`-0.0784`，虽然如此，玩家并没有往下掉，这可能是因为脚下有方块的时候就不往下掉，该值可能是为了制造重力。\n这也可以说明，为什么`Friction`调到很小(如0.01)的时候攻击玩家几乎无击退，因为这时`motY`除以`0.01`会变成`-7.84`，强力压在地上，导致地面对玩家的摩擦力较大，使玩家难以移动。\n如果玩家在水中踩到地面，该值为`-0.02`(也许是重力减去浮力？)\n\n回到一开始，再次看到这个函数\n\n![EntityLiving2.png](https://i.loli.net/2020/04/01/rSVGJyPlBKc6HDW.png)\n\n首先**受害者**受到了**攻击者**的一次攻击。在计算击退之前，**受害者**目前的速度除以Friction以缩短目前的速度(见上方`Friction`)。通常该值只作用于玩家正在移动的过程中，比如疾跑或者正在被击退。如果玩家是静止的，那么`motX`和`motZ`都是0。\n如果玩家是在下落状态，则`motY`是负值，如果这个时候玩家受到攻击，`motY`会缩小，下落速度会变慢，这也是玩家在空中掉落的过程中受到攻击时会顿一下的原因。\n\n我们知道：\n\n- d0为**攻击者**位置的X值减去**受害者**位置的X值，即为从**受害者**到**攻击者**的向量的X值。\n- d1为**攻击者**位置的Z值减去**受害者**位置的X值，即为从**受害者**到**攻击者**的向量的Z值。\n- f1为从**受害者**到**攻击者**的向量在水平面投影的长度。\n\n因此将d0和d1都除以f1后，向量`(d0/f1, d1/f1)`的模为1。\n我们可以把一个长度为1的向量称为单位向量，它通常只为了表示方向。我们将把向量除以它的模的过程称为标准化向量，通常我们在只需要表示向量的方向，长度不重要，且要求该向量模为1的时候这样做。\n接着两个值再乘以`f2`，即乘以0.4，表示把向量乘以0.4，也就是说把向量的模改为 根号0.32 。此时，水平面上的击退原始数据就计算完毕了。\n\n至于为什么`motX`和`motZ`是减去运算得出的数值，是因为上面算出来的向量是从**受害者**指向**攻击者**的向量，我们需要让**受害者**往后击退，而不是往**攻击者**飞过去，所以才是减去。\n\n再看到竖直上的击退，直接是目前的`motY`加上f2。最后，如果`motY`超过一个限制值(每错，就是那个小数点后老长的)，就设为那个限制值。您可能会问，才加0.4可能会超过吗？确实会，因为上面说过，在**受害者**再一次受到伤害前，玩家是飞在空中的。如果是combo模式(即玩家受到攻击后的无敌时间很短)，**受害者**再一次受到攻击时`motY`还很大，除以Friction后可能依然很大，所以为防止玩家飞起来就设置了一个限制值。\n\n\n\n再来看击退修正，\n\n![EntityHuman1.png](https://i.loli.net/2020/04/01/kxVR9mA1EsTNfOG.png)\n\n`entity.g` 这个函数可以理解为原速度加上目标速度，如\n`entity.g(1, 2, 3)`就是`entity.motX += 1; entity.motY += 2; entity.motZ += 3; `\n`yaw * π / 180`就是将玩家朝向的欧拉角yaw值(角度)转为弧度。\n在MC中，yaw的范围是`-180~179.9`。\n也就是说，这里的`-sin(yaw * π / 180)`和`cos(yaw * π / 180)`依然是生成一个模为1的矢量。为什么模为1？我们把`yaw * π / 180`设为θ，由sin²θ + cos²θ = 1可知，该向量模为1。\n将该向量乘以`i` 再乘以`0.5`，即可得到水平上修正的向量。\n其中，`i`默认为`0`，如果玩家在疾跑状态则`+1`，如果玩家手上的物品有击退附魔，则再+击退附魔等级。\n最后，`motY`再加`0.1`。\n在原版中，如果`i>0`，才会执行这段代码，如果`i=0`，则该代码不被执行，也就是说，`motY`也不会`+0.1`。\n在著名服务端mSpigot上，由于i默认为1，且疾跑不影响i的值，所以该代码永远会被执行。\n最后，把算到的击退交给事件触发器，由事件再次对向量进行更改(如果有的话)，最终将击退速度发送给客户端。\n\n我们可以看到，在算击退原始数据时，击退的方向是以玩家间的位置关系决定的。而在修正的过程中，却由**攻击者**的yaw值决定。这是印证了上面的实验。所以，如果有个玩家开挂，拿着击退棒背对着打你(请使用不会转过头去打的祖宗级秒被ban外挂实验并关闭反作弊)，你并不会往后退反而往黑客的方向飞去，也是这个道理。\n\n## 如何~~抄袭~~猜测某服务器的击退\n如果该服务器的击退数值不是离散的(在相同情况下，击退总是相同，没有产生随机偏移)，且算法为MC原版算法，那么该服的击退数值将非常好猜。\n\n如果击退数值是离散的，那么可以通过统计算出击退数值的分布，然后根据分布的情况模拟随机的数值。比如上方的`Math.random() - Math.random()`就是-1~1中呈金字塔形的分布，如果是`Math.random()-0.5`就是在`-0.5~0.5`比较均匀的分布。除此之外，还有正态分布(`new Random().nextGaussian();`)等常见分布方式。\n\n我们需要的随机偏移一般不能太大，所以再乘以一个数如0.1缩小随机偏移量的范围。最后根据统计得出的分布规律猜测偏移的算法即可。\n\n由于每次击退服务器只会给你发送一个速度矢量，不可能在击退的过程中持续修正你的速度(不然延迟高的话就会乱飘。速度给你造成的位移一般由客户端计算)。所以，我们只要得出在各种情况下每次服务器发来的击退赋予的速度即可反推击退数值。\n\n> 为了方便获取击退数值，我特意写了一个mod来辅助您获取某服务器的击退。\n> 版本: 1.8.9\n> 请使用最新版本forge运行以保证兼容性(我们使用的forge版本是forge1.8.9-11.15.1.2318)\n> <s>当然，别对该mod抱有太大期望，比如按f3会挡住啥的</s>\n> 链接: https://pan.baidu.com/s/11BJ3Rtw-4YTDXECzIXWzAg 提取码: 77f3 \n\n这个mod看起来是这样的：\n\n![mod.png](https://i.loli.net/2020/04/03/l9fwgMSd5ATVFD7.png)\n\n<s>什么？你被查端的时候因为这个太像挂端被封了？怪我咯</s>\n\n- Sprint: 你是否为疾跑状态\n- Sneak: 你是否为潜行状态\n- OnGround: 您是否站在地面\n  - 站在地面，指是否落地并站在地面。\n  - 如果玩家被击飞、或者跳跃，该值为false。\n  - 不过，如果玩家是在飞行状态，即使他的坐标是贴合地面的，OnGround也一定为false。\n- MotionX: 您的速度矢量的X值\n- MotionY: 您的速度矢量的Y值\n- MotionZ: 您的速度矢量的Z值\n- Target: 您正在攻击的玩家的名字\n- Distance: 您与您正在攻击的玩家的距离\n- ShadowDistance: 您与您正在攻击的玩家的连线在水平面上的投影的距离\n  - 为什么需要水平面上的投影的距离？如果您有看上方原版击退的算法的话，您就会明白，击退的y值是另算的，玩家之间的位置关系只会决定x和z，y几乎不受玩家间位置影响。\n- TargetSprint: 您正在攻击的玩家是否为疾跑状态\n- TargetSneak: 您正在攻击的玩家是否为潜行状态\n- TargetOnGround: 您正在攻击的玩家是否站在地面\n\n!!! note 为什么不顺便列出对方的速度矢量？\n    这是因为对方速度是服务器决定的，服务器只要告诉您对方的位置就可以了。服务端没必要把跟您无关的数据一并发送给您，浪费服务器资源，所以对方的速度矢量无意义。\n\n    准备好后，您可以找一个小伙伴，一起装这个mod，然后进入您想测试击退的服务器。接着双方各开启录制~~(建议120帧)~~，模拟出各种情况，然后在视频剪辑软件中看每次攻击时赋予的速度即可。\n\n    一定要记住有Friction这个值，也就是每次击退的时候会先削减**受害者**的速度，再加上计算出来的击退，不然在combo的时候每次值都不一样别以为是random再作祟。\n\n### 算法区别\n你猜测kb的服务器的算法不一定是原版算法，所以当您暴力计算后没得出任何结果的话，您可以再分析总体数据的变化和产生数据对应的情况去猜测算法。即便算法不一定相同，但只要最终算出来的结果是一样的，您的击退和你在~~抄~~的服务器的击退就是一样的。\n\n!!! note \"\"\n    syuu和kar都是使用了不同于原版的击退算法。\n\n然后您可以写一个算法暴力算出误差小于0.0001的击退。\n\n### 如何防止自己服的kb被盗\n使最终计算出来的kb离散化，加上一些微小的随机的偏移，且使用的随机算法也是随机的(不然容易被使用统计方法算出随机算法)。总之，尽量在不影响kb总体感觉的情况下提高猜测kb的难度。\n\n## 关于本文档\n\n文档的主要研究者与作者: LSeng\n\n文档编写参与者: CarmJos","tags":["kar","MineCraft游戏开发"],"categories":["开发经验分享"]}]